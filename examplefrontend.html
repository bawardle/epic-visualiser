<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure DevOps User Story Visualizer</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }
        .user-story-card {
            position: absolute;
            cursor: grab;
            transition: all 0.3s ease;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .user-story-card:active {
            cursor: grabbing;
            transform: scale(1.05);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="app" class="relative w-full h-screen overflow-hidden p-8">
        <div class="absolute top-4 left-4 z-10">
            <h1 class="text-3xl font-bold text-white">User Story Relationship Visualizer</h1>
            <p class="text-gray-400">Drag and drop the cards to rearrange the layout.</p>
        </div>

        <svg class="absolute top-0 left-0 w-full h-full" style="z-index: 0;">
            <defs>
                <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
                    markerWidth="6" markerHeight="6"
                    orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#fff" />
                </marker>
            </defs>
            <line v-for="line in lines"
                :x1="line.x1" :y1="line.y1"
                :x2="line.x2" :y2="line.y2"
                stroke="#ffffff" stroke-width="3"
                marker-end="url(#arrow)"
                />
        </svg>

        <user-story-card
            v-for="(story, index) in stories"
            :key="story.Id"
            :story="story"
            :style="{ top: story.y + 'px', left: story.x + 'px' }"
            @mousedown="startDrag($event, story)"
        ></user-story-card>
    </div>

    <script type="text/x-template" id="user-story-card-template">
        <div class="user-story-card w-64 p-4 rounded-lg border-2" :class="cardClasses">
            <div class="font-bold text-lg mb-2">ID: {{ story.Id }}</div>
            <p class="text-sm mb-2 h-12 overflow-hidden"><strong>Name:</strong> {{ story.Name.substring(0, 40) }}...</p>
            <div class="text-xs">
                <p><strong class="font-semibold">State:</strong> {{ story.State || 'N/A' }}</p>
                <p class="h-10 overflow-hidden"><strong class="font-semibold">Iteration:</strong> {{ story.Iteration ? story.Iteration.slice(-40) : 'N/A' }}</p>
            </div>
        </div>
    </script>

    <script>
        const UserStoryCard = {
            template: '#user-story-card-template',
            props: ['story'],
            computed: {
                cardClasses() {
                    // Is a precursor to another story (and not a successor)
                    if (this.story.Successor && !this.story.Precursor) {
                        return 'bg-red-200 border-red-500 text-red-800';
                    } 
                    // Is a successor to another story (and not a precursor)
                    else if (this.story.Precursor && !this.story.Successor) {
                        return 'bg-blue-200 border-blue-500 text-blue-800';
                    }
                    // Is both a precursor and a successor (a link in a chain)
                    else if (this.story.Precursor && this.story.Successor) {
                        return 'bg-purple-200 border-purple-500 text-purple-800';
                    }
                    // Standalone story
                    else {
                        return 'bg-green-200 border-green-500 text-green-800';
                    }
                }
            }
        };

        const app = Vue.createApp({
            components: {
                UserStoryCard
            },
            data() {
                return {
                    stories: [],
                    lines: [],
                    draggedStory: null,
                    offsetX: 0,
                    offsetY: 0,
                    // Mock data based on the provided JSON structure
                    mockData: {
                      "user_stories": [
                        { "Id": "4498198", "Name": "User Story - As a user, I want to be able to log in.", "Precursor": null, "Successor": "4489734", "State": "New", "Iteration": "Project\\Sprint 1" },
                        { "Id": "4489734", "Name": "User Story - As a user, I want to see my dashboard.", "Precursor": "4498198", "Successor": "4476685", "State": "Active", "Iteration": "Project\\Sprint 1" },
                        { "Id": "4476685", "Name": "User Story - As a user, I want to view my profile.", "Precursor": "4489734", "Successor": "4457956", "State": "Active", "Iteration": "Project\\Sprint 2" },
                        { "Id": "4457956", "Name": "User Story - As a user, I want to edit my profile information.", "Precursor": "4476685", "Successor": null, "State": "Resolved", "Iteration": "Project\\Sprint 2" },
                        { "Id": "1234567", "Name": "User Story - Standalone feature with a very long name that will be truncated.", "Precursor": null, "Successor": null, "State": "New", "Iteration": "Project\\Backlog\\Really\\Long\\Iteration\\Path\\To\\Showcase\\Truncation" },
                        { "Id": "8888888", "Name": "User Story - Another precursor story for a different chain.", "Precursor": null, "Successor": "9999999", "State": "New", "Iteration": "Project\\Sprint 3" },
                        { "Id": "9999999", "Name": "User Story - Successor to the other chain.", "Precursor": "8888888", "Successor": null, "State": "Active", "Iteration": "Project\\Sprint 3" },
                        { "Id": "7654321", "Name": "User Story - Another standalone item.", "Precursor": null, "Successor": null, "State": "New", "Iteration": "Project\\Backlog" }
                      ]
                    }
                };
            },
            methods: {
                layoutStories() {
                    const storiesById = new Map(this.stories.map(s => [s.Id, s]));

                    // 1. Separate standalone stories from those in a dependency tree
                    const standaloneStories = [];
                    const treeStories = [];
                    this.stories.forEach(story => {
                        if (!story.Precursor && !story.Successor) {
                            standaloneStories.push(story);
                        } else {
                            treeStories.push(story);
                        }
                    });

                    // 2. Layout standalone stories at the bottom, horizontally
                    const PADDING_X_STANDALONE = 300; // Horizontal space between cards
                    const CARD_WIDTH = 256;
                    const BOTTOM_Y = window.innerHeight - 200; // Y position for the bottom row
                    const totalStandaloneWidth = (standaloneStories.length * CARD_WIDTH) + ((standaloneStories.length - 1) * (PADDING_X_STANDALONE - CARD_WIDTH));
                    let startXStandalone = (window.innerWidth - totalStandaloneWidth) / 2;

                    standaloneStories.forEach((story, index) => {
                        // Only set position if it hasn't been set by dragging
                        if (story.x === null) {
                            story.x = startXStandalone + index * PADDING_X_STANDALONE;
                            story.y = BOTTOM_Y;
                        }
                    });

                    // 3. Layout the tree stories from the top
                    const roots = treeStories.filter(s => s.Precursor === null || !storiesById.has(s.Precursor));
                    
                    const levels = [];
                    let currentLevel = roots;
                    const placedStories = new Set(roots.map(r => r.Id));

                    while(currentLevel.length > 0) {
                        levels.push(currentLevel);
                        const nextLevel = [];
                        for(const story of currentLevel) {
                            if(story.Successor && storiesById.has(story.Successor)) {
                                const successor = storiesById.get(story.Successor);
                                if (!placedStories.has(successor.Id)) {
                                    nextLevel.push(successor);
                                    placedStories.add(successor.Id);
                                }
                            }
                        }
                        currentLevel = nextLevel;
                    }

                    const PADDING_X_TREE = 350;
                    const PADDING_Y_TREE = 220;
                    const START_X_TREE = 100;
                    const START_Y_TREE = 150;

                    levels.forEach((level, levelIndex) => {
                        level.forEach((story, storyIndex) => {
                            // Only set position if not already dragged
                            if (story.x === null) {
                                story.x = START_X_TREE + levelIndex * PADDING_X_TREE;
                                story.y = START_Y_TREE + storyIndex * PADDING_Y_TREE;
                            }
                        });
                    });
                    
                    // 4. Position any orphaned stories (e.g., part of a cycle not starting with a root)
                    let orphanYOffset = START_Y_TREE + (levels.length > 0 ? levels[0].length * PADDING_Y_TREE : 0) + 100;
                    treeStories.forEach(story => {
                        if (story.x === null) { // If it still hasn't been placed
                            story.x = START_X_TREE;
                            story.y = orphanYOffset;
                            orphanYOffset += PADDING_Y_TREE;
                        }
                    });

                    this.updateLines();
                },
                updateLines() {
                    const storiesById = new Map(this.stories.map(s => [s.Id, s]));
                    this.lines = [];
                    this.stories.forEach(story => {
                        if (story.Successor && storiesById.has(story.Successor)) {
                            const successor = storiesById.get(story.Successor);
                            this.lines.push({
                                x1: story.x + 256, // from the right edge of the card
                                y1: story.y + 70, // vertically centered
                                x2: successor.x, // to the left edge of the card
                                y2: successor.y + 70 // vertically centered
                            });
                        }
                    });
                },
                startDrag(event, story) {
                    this.draggedStory = story;
                    this.offsetX = event.clientX - story.x;
                    this.offsetY = event.clientY - story.y;
                    document.addEventListener('mousemove', this.doDrag);
                    document.addEventListener('mouseup', this.stopDrag);
                },
                doDrag(event) {
                    if (!this.draggedStory) return;
                    this.draggedStory.x = event.clientX - this.offsetX;
                    this.draggedStory.y = event.clientY - this.offsetY;
                    this.updateLines();
                },
                stopDrag() {
                    this.draggedStory = null;
                    document.removeEventListener('mousemove', this.doDrag);
                    document.removeEventListener('mouseup', this.stopDrag);
                }
            },
            mounted() {
                // Initialize positions as null to track if they've been manually moved
                this.stories = this.mockData.user_stories.map(story => ({...story, x: null, y: null}));
                this.layoutStories();
                window.addEventListener('resize', this.layoutStories);
            },
            beforeUnmount() {
                window.removeEventListener('resize', this.layoutStories);
            }
        });

        app.mount('#app');
    </script>
</body>
</html>
